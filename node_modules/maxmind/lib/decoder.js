"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const assert_1 = __importDefault(require("assert"));
const tiny_lru_1 = __importDefault(require("tiny-lru"));
const utils_1 = __importDefault(require("./utils"));
assert_1.default(typeof BigInt !== 'undefined', 'Apparently you are using old version of node. Please upgrade to node 10.4.x or above.');
const types = [
    'extended',
    'pointer',
    'utf8_string',
    'double',
    'bytes',
    'uint16',
    'uint32',
    'map',
    'int32',
    'uint64',
    'uint128',
    'array',
    'container',
    'end_marker',
    'boolean',
    'float',
];
const pointerValueOffset = [0, 2048, 526336, 0];
const cursor = (value, offset) => ({ value, offset });
class Decoder {
    constructor(db, baseOffset = 0, opts) {
        this.telemetry = {};
        assert_1.default((this.db = db), 'File stream is required');
        this.baseOffset = baseOffset;
        this.cache = tiny_lru_1.default(opts && opts.cache && opts.cache.max ? opts.cache.max : 6000);
    }
    decode(offset) {
        let tmp;
        const ctrlByte = this.db[offset++];
        let type = types[ctrlByte >> 5];
        if (type === 'pointer') {
            tmp = this.decodePointer(ctrlByte, offset);
            return cursor(this.decodeFast(tmp.value).value, tmp.offset);
        }
        if (type === 'extended') {
            tmp = this.db[offset] + 7;
            if (tmp < 8) {
                throw new Error('Invalid Extended Type at offset ' + offset + ' val ' + tmp);
            }
            type = types[tmp];
            offset++;
        }
        const size = this.sizeFromCtrlByte(ctrlByte, offset);
        return this.decodeByType(type, size.offset, size.value);
    }
    decodeFast(offset) {
        const cached = this.cache.get(offset);
        if (cached) {
            return cached;
        }
        const result = this.decode(offset);
        this.cache.set(offset, result);
        return result;
    }
    decodeByType(type, offset, size) {
        const newOffset = offset + size;
        switch (type) {
            case 'utf8_string':
                return cursor(this.decodeString(offset, size), newOffset);
            case 'map':
                return this.decodeMap(size, offset);
            case 'uint32':
                return cursor(this.decodeUint(offset, size), newOffset);
            case 'double':
                return cursor(this.decodeDouble(offset), newOffset);
            case 'array':
                return this.decodeArray(size, offset);
            case 'boolean':
                return cursor(this.decodeBoolean(size), offset);
            case 'float':
                return cursor(this.decodeFloat(offset), newOffset);
            case 'bytes':
                return cursor(this.decodeBytes(offset, size), newOffset);
            case 'uint16':
                return cursor(this.decodeUint(offset, size), newOffset);
            case 'int32':
                return cursor(this.decodeInt32(offset, size), newOffset);
            case 'uint64':
                return cursor(this.decodeUint(offset, size), newOffset);
            case 'uint128':
                return cursor(this.decodeUint(offset, size), newOffset);
        }
        throw new Error('Unknown type ' + type + ' at offset ' + offset);
    }
    sizeFromCtrlByte(ctrlByte, offset) {
        const size = ctrlByte & 0x1f;
        if (size < 29) {
            return cursor(size, offset);
        }
        if (size === 29) {
            return cursor(29 + this.db[offset], offset + 1);
        }
        if (size === 30) {
            return cursor(285 + this.db.readUInt16BE(offset, false), offset + 2);
        }
        return cursor(65821 +
            utils_1.default.concat3(this.db[offset], this.db[offset + 1], this.db[offset + 2]), offset + 3);
    }
    decodeBytes(offset, size) {
        return this.db.slice(offset, offset + size);
    }
    decodePointer(ctrlByte, offset) {
        const pointerSize = (ctrlByte >> 3) & 3;
        const pointer = this.baseOffset + pointerValueOffset[pointerSize];
        let packed = 0;
        if (pointerSize === 0) {
            packed = utils_1.default.concat2(ctrlByte & 7, this.db[offset]);
        }
        else if (pointerSize === 1) {
            packed = utils_1.default.concat3(ctrlByte & 7, this.db[offset], this.db[offset + 1]);
        }
        else if (pointerSize === 2) {
            packed = utils_1.default.concat4(ctrlByte & 7, this.db[offset], this.db[offset + 1], this.db[offset + 2]);
        }
        else {
            packed = this.db.readUInt32BE(offset, true);
        }
        offset += pointerSize + 1;
        return cursor(pointer + packed, offset);
    }
    decodeArray(size, offset) {
        let tmp;
        const array = [];
        for (let i = 0; i < size; i++) {
            tmp = this.decode(offset);
            offset = tmp.offset;
            array.push(tmp.value);
        }
        return cursor(array, offset);
    }
    decodeBoolean(size) {
        return size !== 0;
    }
    decodeDouble(offset) {
        return this.db.readDoubleBE(offset, true);
    }
    decodeFloat(offset) {
        return this.db.readFloatBE(offset, true);
    }
    decodeMap(size, offset) {
        let tmp;
        let key;
        const map = {};
        for (let i = 0; i < size; i++) {
            tmp = this.decode(offset);
            key = tmp.value;
            tmp = this.decode(tmp.offset);
            offset = tmp.offset;
            map[key] = tmp.value;
        }
        return cursor(map, offset);
    }
    decodeInt32(offset, size) {
        if (size === 0) {
            return 0;
        }
        return this.db.readInt32BE(offset, true);
    }
    decodeUint(offset, size) {
        switch (size) {
            case 0:
                return 0;
            case 1:
                return this.db[offset];
            case 2:
                return utils_1.default.concat2(this.db[offset + 0], this.db[offset + 1]);
            case 3:
                return utils_1.default.concat3(this.db[offset + 0], this.db[offset + 1], this.db[offset + 2]);
            case 4:
                return utils_1.default.concat4(this.db[offset + 0], this.db[offset + 1], this.db[offset + 2], this.db[offset + 3]);
            case 8:
                return this.decodeBigUint(offset, size);
            case 16:
                return this.decodeBigUint(offset, size);
        }
        return 0;
    }
    decodeString(offset, size) {
        return this.db.utf8Slice(offset, offset + size);
    }
    decodeBigUint(offset, size) {
        const buffer = Buffer.alloc(size);
        this.db.copy(buffer, 0, offset, offset + size);
        let integer = BigInt(0);
        const numberOfLongs = size / 4;
        for (let i = 0; i < numberOfLongs; i++) {
            integer =
                integer * BigInt(4294967296) +
                    BigInt(buffer.readUInt32BE(i << 2, true));
        }
        return integer.toString();
    }
}
exports.default = Decoder;
//# sourceMappingURL=decoder.js.map