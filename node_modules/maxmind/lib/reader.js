"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const decoder_1 = __importDefault(require("./decoder"));
const ip_1 = __importDefault(require("./ip"));
const metadata_1 = require("./metadata");
const walker_1 = __importDefault(require("./reader/walker"));
const DATA_SECTION_SEPARATOR_SIZE = 16;
class Reader {
    constructor(db, opts) {
        opts = opts || {};
        this.db = db;
        this.metadata = metadata_1.parseMetadata(this.db);
        this.decoder = new decoder_1.default(this.db, this.metadata.searchTreeSize + DATA_SECTION_SEPARATOR_SIZE, opts);
        this.walker = walker_1.default(this.db, this.metadata.recordSize);
    }
    load(db, opts) {
        this.db = db;
        this.metadata = metadata_1.parseMetadata(this.db);
        this.decoder = new decoder_1.default(this.db, this.metadata.searchTreeSize + DATA_SECTION_SEPARATOR_SIZE, opts);
        this.walker = walker_1.default(this.db, this.metadata.recordSize);
    }
    get(ipAddress) {
        const pointer = this.findAddressInTree(ipAddress);
        return pointer ? this.resolveDataPointer(pointer) : null;
    }
    findAddressInTree(ipAddress) {
        const rawAddress = ip_1.default.parse(ipAddress);
        const nodeCount = this.metadata.nodeCount;
        const ipStartBit = this.metadata.ipVersion === 6 && rawAddress.length === 4 ? 128 - 32 : 0;
        let bit;
        let nodeNumber = ipStartBit;
        let pointer;
        let offset;
        for (let i = ipStartBit; i < this.metadata.treeDepth; i++) {
            bit = ip_1.default.bitAt(rawAddress, i - ipStartBit);
            offset = nodeNumber * this.metadata.nodeByteSize;
            pointer = bit ? this.walker.right(offset) : this.walker.left(offset);
            if (pointer < nodeCount) {
                nodeNumber = pointer;
            }
            else if (pointer > nodeCount) {
                return pointer;
            }
            else {
                return null;
            }
        }
        return null;
    }
    resolveDataPointer(pointer) {
        const resolved = pointer - this.metadata.nodeCount + this.metadata.searchTreeSize;
        return this.decoder.decodeFast(resolved).value;
    }
}
exports.default = Reader;
//# sourceMappingURL=reader.js.map